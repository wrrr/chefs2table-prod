"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverse = void 0;
/**
 * Recursively traverses an object or array, invoking a callback on each value.
 *
 * @param {any} obj - The object or array to traverse. Can also handle primitives, null, or undefined.
 * @param {TraverseCallback} callback - The function to invoke on each value. Receives the current value
 * and an `update` function to modify the value in its parent container.
 * @param {any} [parent=null] - The parent object or array of the current value. Used internally.
 * @param {any} [key=null] - The key or index of the current value in its parent. Used internally.
 * @param {WeakSet} [visited=new WeakSet()] - Tracks visited objects to handle circular references. Used internally.
 *
 * @example
 * // Example: Doubling all numbers in an object
 * const obj = { a: 1, b: [2, 3, { c: 4 }] };
 * traverse(obj, (value, update) => {
 *   if (typeof value === 'number') {
 *     update(value * 2);
 *   }
 * });
 * console.log(obj); // { a: 2, b: [4, 6, { c: 8 }] }
 *
 * @example
 * // Example: Handling circular references
 * const obj = { a: 1 };
 * obj.self = obj;
 * traverse(obj, (value, update) => {
 *   if (typeof value === 'number') {
 *     update(value * 2);
 *   }
 * });
 * console.log(obj.a); // 2
 */
function traverse(obj, callback, parent, key, visited) {
    if (parent === void 0) { parent = null; }
    if (key === void 0) { key = null; }
    if (visited === void 0) { visited = new WeakSet(); }
    if (obj == null || typeof obj !== 'object') {
        callback(obj, function (newValue) {
            if (parent !== null && key !== null) {
                parent[key] = newValue;
            }
        });
        return;
    }
    if (visited.has(obj)) {
        return;
    }
    visited.add(obj);
    if (Array.isArray(obj)) {
        obj.forEach(function (item, index) {
            var update = function (newValue) {
                obj[index] = newValue;
            };
            callback(item, update);
            traverse(item, callback, obj, index, visited);
        });
    }
    else {
        Object.entries(obj).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            var update = function (newValue) {
                obj[key] = newValue;
            };
            callback(value, update);
            traverse(value, callback, obj, key, visited);
        });
    }
}
exports.traverse = traverse;
//# sourceMappingURL=traverse.js.map